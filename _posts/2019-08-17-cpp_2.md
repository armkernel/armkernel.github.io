---
layout : post
title : Cpp study_190817
tags : [Cpp]
comments: true
---
### C++ study (Lec.)

#### constructor 

- 객체를 생성하면 생성자가 호출 된다. 이 때, 객체가 상속받은 객체라면, 기반 클래스의 생성자도 호출 된다. 만약, 객체 내에 맴버 데이터가 객체라면, 그 객체의 생성자도 호출된다. 
- 객체의 생성자 호출  순서는 메모리에 적재된 순서로 호출 되게 된다. e.g. 기반 클래스 / 파생 클래스 --> 기반 클래스 먼저 호출 파생클래스 호출 

- 만약 객체가 생성자를 만들지 않는다면, 암묵적으로 compiler가 생성해준다. 하지만, 사용자가 생성자를 정의한다면, 사용자가 생성자를 호출한다.

- 생성자의 특징
  1. 파생 클래스 생성시, 기반 클래스의 생성자가 먼저 호출 된다.
  2. 기반 클래스의 생성자는 항상 디폴트 생성자를 호출하도록 한다. 만약, 디폴트 생성자가 없다면 오류가 발생하며, 오류를 피하길 원한다면 사용자가 직접 정의해 호출하면 된다.
  3. 기반 클래스에 디폴트 생성자가 없는 경우 파생클래의 객체를 만들 수 없다.
  4. 초기화 리스트를 이용해 초기화는 가능하다. 

  - 예를 들어 정리해보자면, 기반 클래스 내 디폴트 생성자는 없지만 인자 2개를 가진 생성자가 있을 경우 파생 클래스에서 초기화 >    리스트에 기반 클래스를 인자 두개로 생성하도록 해 생성자를 직접 호출하면 오류가 사라짐

- 생성자는 가상함수를 지원하지 않는다.
  - 가상함수를 왜 지원하지 않을까?
    - 파생 클래스에서 가상함수를 재정의 하는 클래스가 있다고 가정해보자. 파생클래스의 가상함수는 자신의 맴버데이터를 출력해주는 함수라고 가정해보자. 또한, 기반 클래스에서 가상함수를 호출한다고 해보자. 이 때, 파생 클래스의 객체를 생성하고, 파생클래스의 생성자에서 자신의 맴버데이터를 초기화 리스트를 이용해 초기화 할 경우 문제가 발생한다. 
    - 파생클래스의 객체를 생성할 경우 기반 클래스가 먼저 호출 되게 된다. 기반 클래스의 생성자에서 가상함수를 호출 할 경우 초기화 리스트로 초기화 되기도 전의 값을 가상함수를 통해 부를수 있는 경우가 발생한다. 이런 문제 때문에 생성자에서는 가상함수를 지원하지 않는다.
    ```cpp
    class parent {
      public:
        parent() { print(); } 
        virtual print(); // 가상함수 일경우 문제 발생.. 생성자 호출시..
    }    

    class child {
      private:
        int data;
      public:
        child() : data(data) {}
        virtual print() { cout << my data is << data << endl; }
    }

    ```

- 생성자에서 예외가 발생할 경우
  - 생성자에서 예외가 발생할 경우, 따로 관리할 수 있는 방법이 없다. return 값이 없기 때문에 어떤 에러가 발생했는지를 체크할 수 없다. 따라서, 예외를 던져서 try catch 문을 이용해 예외를 처리해야한다. 만약 생성자 내에서 어떤 값을 동적할 경우 문제가 발생한다. 동적할당을 한후 예외가 발생할 경우 자원을 회수 할 방법이 없다. ***소멸자가 불리지 않기 때문에*** 자원을 회수할 방법이 존재하지 않는다. 
  - 이 문제를 해결하는 방법 
    - smart pointer
      - smart pointer를 선언해 동적할당 받는 부분을 자동적으로 생성 및 해제할 수 있도록 한다.
    - two phase creator 
      - 생성자와 실제 데이터를 동적할당 하는 부분으로 나누어 관리한다.
      - 이 컨셉은 디자인 패턴에서 많이 사용한다. 
        - iostream 내에서 버퍼를 할당하는 부분을 이렇게 많이 사용함.
