---
layout : post
title : "[C++ OOP] Protected constructor"
tags : [Design Pattern]
comments: true
---
### Protected 생성자
> 간혹 오픈소스들을 보다보면, 생성자를 protected에 두는 경우가 있다. 왜 그런지 알아보자.

```c
#include <iostream>
using namespace std;

class Animal
{
protected:
  Animal() {};
};

class Dog : public Animal
{
public:
  Dog() {};
};

int main()
{
  Animal a; // error
  Dog d;    // ok..
}

```

- 위의 소스코드를 보면, 생성자가 protected에 생성되어져있다. 이렇게 소스코드를 작성하게 된다면, Animal 클래스는 외부에서 선언이 불가능하다. 때문에, Animal 객체를 외부에서 만들 경우 주석과 같은 compile error가 발생한다. 

- 그렇다면, Dog 클래스는 생성이 가능할까?
  - 가능하다. 그 이유는 생성자의 호출 순서 때문에 컴파일 에러 없이 생성이 가능하다.
  - 생성자 호출 순서
    - Dog();
    - Animal(); -> 기반 클래스에서 상속받았음으로 호출이 가능함.

- 왜 이렇게 작성하는 것일까?
  - ***디자인 관점*** 에서 생각해보자면, 외부에서 추상클래스 같은 경우 생성이 되지 않아야한다. 하지만, 파생클래스에서는 추상클래스의 기능이나 데이터들을 포함해야하기 때문에 위와 같이 코드를 종종작성한다. 조금 더 나아가면, virtual이라는 기법이 등장을 한다. virtual 같은 경우 가상의 테이블을 유지해야한다는 오버헤드가 존재한다. 따라서, open source에서는 필요에 따라 이렇게도 구현이 가능하다는 것을 알아두자.


- <mark> 핵심 </mark> 기억할 것.
  - 기반 클래스로 상속 받은 파생 클래스를 객체화 할 경우 생성자의 호출 순서
    - 파생 클래스에 도달 한 후 기반클래스를 부른다. 즉, 바로 기반 클래스를 부르지 않는다. 따라서, 파생클래스에 도달한 후 protected의 속성으로 인해 상속받은 기반클래스의 생성자를 호출 하는 것이다. (다소 햇갈리 수 있는 부분이 있지만.. 속성을 조금 생각해보면 이해할 수 있다.)

  - 디자인 관점에서 생각해보면, 현실세계와 동일하게 추상 클래스는 외부에서는 생성이 되면 안된다는 것을 기억하자. 
